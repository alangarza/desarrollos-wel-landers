/*!
* Parsley.js
* Version 2.8.1 - built Sat, Feb 3rd 2018, 2:27 pm
* http://parsleyjs.org
* Guillaume Potier - <guillaume@wisembly.com>
* Marc-Andre Lafortune - <petroselinum@marc-andre.ca>
* MIT Licensed
*/
// The source code below is generated by babel as
// Parsley is written in ECMAScript 6
//
function _toConsumableArray(e){if(Array.isArray(e)){for(var t=0,i=Array(e.length);t<e.length;t++)i[t]=e[t];return i}return Array.from(e)}var _slice=Array.prototype.slice,_slicedToArray=function(){function i(e,t){var i=[],r=!0,n=!1,s=void 0;try{for(var a=e[Symbol.iterator](),o;!(r=(o=a.next()).done)&&(i.push(o.value),!t||i.length!==t);r=!0);}catch(e){n=!0,s=e}finally{try{!r&&a.return&&a.return()}finally{if(n)throw s}}return i}return function(e,t){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return i(e,t);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_extends=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var i=arguments[t];for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(e[r]=i[r])}return e};!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t(require("jquery")):"function"==typeof define&&define.amd?define(["jquery"],t):e.parsley=t(e.jQuery)}(this,function(p){"use strict";
// Returns an event handler that calls `fn` with the arguments it expects
function n(t,i){
// Store to allow unbinding
return t.parsleyAdaptedCallback||(t.parsleyAdaptedCallback=function(){var e=Array.prototype.slice.call(arguments,0);e.unshift(this),t.apply(i||R,e)}),t.parsleyAdaptedCallback}
// Converts 'parsley:form:validate' into 'form:validate'
function s(e){return 0===e.lastIndexOf(T,0)?e.substr(T.length):e}
// $.listen is deprecated. Use Parsley.on instead.
/**
   * inputevent - Alleviate browser bugs for input events
   * https://github.com/marcandre/inputevent
   * @version v0.0.3 - (built Thu, Apr 14th 2016, 5:58 pm)
   * @author Marc-Andre Lafortune <github@marc-andre.ca>
   * @license MIT
   */
function e(){var n=this,s=window||global;
// Slightly odd way construct our object. This way methods are force bound.
// Used to test for duplicate library.
_extends(this,{
// For browsers that do not support isTrusted, assumes event is native.
isNativeEvent:function e(t){return t.originalEvent&&!1!==t.originalEvent.isTrusted},fakeInputEvent:function e(t){n.isNativeEvent(t)&&p(t.target).trigger("input")},misbehaves:function e(t){n.isNativeEvent(t)&&(n.behavesOk(t),p(document).on("change.inputevent",t.data.selector,n.fakeInputEvent),n.fakeInputEvent(t))},behavesOk:function e(t){n.isNativeEvent(t)&&p(document).off("input.inputevent",t.data.selector,n.behavesOk).off("change.inputevent",t.data.selector,n.misbehaves)},
// Bind the testing handlers
install:function e(){if(!s.inputEventPatched){s.inputEventPatched="0.0.3";for(var t=["select",'input[type="checkbox"]','input[type="radio"]','input[type="file"]'],i=0;i<t.length;i++){var r=t[i];p(document).on("input.inputevent",r,{selector:r},n.behavesOk).on("change.inputevent",r,{selector:r},n.misbehaves)}}},uninstall:function e(){delete s.inputEventPatched,p(document).off(".inputevent")}})}var t=1,i={},h={
// Parsley DOM-API
// returns object from dom attributes and values
attr:function e(t,i,r){var n,s,a,o=new RegExp("^"+i,"i");if(void 0===r)r={};else
// Clear all own properties. This won't affect prototype's values
for(n in r)r.hasOwnProperty(n)&&delete r[n];if(!t)return r;for(n=(a=t.attributes).length;n--;)(s=a[n])&&s.specified&&o.test(s.name)&&(r[this.camelize(s.name.slice(i.length))]=this.deserializeValue(s.value));return r},checkAttr:function e(t,i,r){return t.hasAttribute(i+r)},setAttr:function e(t,i,r,n){t.setAttribute(this.dasherize(i+r),String(n))},getType:function e(t){return t.getAttribute("type")||"text"},generateID:function e(){return""+t++},
/** Third party functions **/
deserializeValue:function e(t){var i;try{return t?"true"==t||"false"!=t&&("null"==t?null:isNaN(i=Number(t))?/^[\[\{]/.test(t)?JSON.parse(t):t:i):t}catch(e){return t}},
// Zepto camelize function
camelize:function e(t){return t.replace(/-+(.)?/g,function(e,t){return t?t.toUpperCase():""})},
// Zepto dasherize function
dasherize:function e(t){return t.replace(/::/g,"/").replace(/([A-Z]+)([A-Z][a-z])/g,"$1_$2").replace(/([a-z\d])([A-Z])/g,"$1_$2").replace(/_/g,"-").toLowerCase()},warn:function e(){var t;window.console&&"function"==typeof window.console.warn&&(t=window.console).warn.apply(t,arguments)},warnOnce:function e(t){i[t]||(i[t]=!0,this.warn.apply(this,arguments))},_resetWarnings:function e(){i={}},trimString:function e(t){return t.replace(/^\s+|\s+$/g,"")},parse:{date:function e(t){var i=t.match(/^(\d{4,})-(\d\d)-(\d\d)$/);if(!i)return null;var r=i.map(function(e){return parseInt(e,10)}),n=_slicedToArray(r,4),s=n[0],a=n[1],o=n[2],l=n[3],e=new Date(a,o-1,l);return e.getFullYear()!==a||e.getMonth()+1!==o||e.getDate()!==l?null:e},string:function e(t){return t},integer:function e(t){return isNaN(t)?null:parseInt(t,10)},number:function e(t){if(isNaN(t))throw null;return parseFloat(t)},boolean:function e(t){return!/^\s*false\s*$/i.test(t)},object:function e(t){return h.deserializeValue(t)},regexp:function e(t){var i="";
// Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern
// Again, replace the regexp literal string with the first match group:
// everything excluding the opening and closing slashes and the flags
return t=/^\/.*\/(?:[gimy]*)$/.test(t)?(
// Replace the regexp literal string with the first match group: ([gimy]*)
// If no flag is present, this will be a blank string
i=t.replace(/.*\/([gimy]*)$/,"$1"),t.replace(new RegExp("^/(.*?)/"+i+"$"),"$1")):"^"+t+"$",new RegExp(t,i)}},parseRequirement:function e(t,i){var r=this.parse[t||"string"];if(!r)throw'Unknown requirement specification: "'+t+'"';var n=r(i);if(null===n)throw"Requirement is not a "+t+': "'+i+'"';return n},namespaceEvents:function e(t,i){return(t=this.trimString(t||"").split(/\s+/))[0]?p.map(t,function(e){return e+"."+i}).join(" "):""},difference:function e(t,i){
// This is O(N^2), should be optimized
var r=[];return p.each(t,function(e,t){-1==i.indexOf(t)&&r.push(t)}),r},
// Alter-ego to native Promise.all, but for jQuery
all:function e(t){
// jQuery treats $.when() and $.when(singlePromise) differently; let's avoid that and add spurious elements
return p.when.apply(p,_toConsumableArray(t).concat([42,42]))},
// Object.create polyfill, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create#Polyfill
objectCreate:Object.create||(r=function e(){},function(e){if(1<arguments.length)throw Error("Second argument not supported");if("object"!=typeof e)throw TypeError("Argument must be an object");r.prototype=e;var t=new r;return r.prototype=null,t}),_SubmitSelector:'input[type="submit"], button:submit'},r,a={
// ### General
// Default data-namespace for DOM API
namespace:"data-parsley-",
// Supported inputs by default
inputs:"input, textarea, select",
// Excluded inputs by default
excluded:"input[type=button], input[type=submit], input[type=reset], input[type=hidden]",
// Stop validating field on highest priority failing constraint
priorityEnabled:!0,
// ### Field only
// identifier used to group together inputs (e.g. radio buttons...)
multiple:null,
// identifier (or array of identifiers) used to validate only a select group of inputs
group:null,
// ### UI
// Enable\Disable error messages
uiEnabled:!0,
// Key events threshold before validation
validationThreshold:3,
// Focused field on form validation error. 'first'|'last'|'none'
focus:"first",
// event(s) that will trigger validation before first failure. eg: `input`...
trigger:!1,
// event(s) that will trigger validation after first failure.
triggerAfterFailure:"input",
// Class that would be added on every failing validation Parsley field
errorClass:"parsley-error",
// Same for success validation
successClass:"parsley-success",
// Return the `$element` that will receive these above success or error classes
// Could also be (and given directly from DOM) a valid selector like `'#div'`
classHandler:function e(t){},
// Return the `$element` where errors will be appended
// Could also be (and given directly from DOM) a valid selector like `'#div'`
errorsContainer:function e(t){},
// ul elem that would receive errors' list
errorsWrapper:'<ul class="parsley-errors-list"></ul>',
// li elem that would receive error message
errorTemplate:"<li></li>"},o=function e(){this.__id__=h.generateID()};o.prototype={asyncSupport:!0,// Deprecated
_pipeAccordingToValidationResult:function e(){var i=this,t=function e(){var t=p.Deferred();return!0!==i.validationResult&&t.reject(),t.resolve().promise()};return[t,t]},actualizeOptions:function e(){return h.attr(this.element,this.options.namespace,this.domOptions),this.parent&&this.parent.actualizeOptions&&this.parent.actualizeOptions(),this},_resetOptions:function e(t){
// Shallow copy of ownProperties of initOptions:
for(var i in this.domOptions=h.objectCreate(this.parent.options),this.options=h.objectCreate(this.domOptions),t)t.hasOwnProperty(i)&&(this.options[i]=t[i]);this.actualizeOptions()},_listeners:null,
// Register a callback for the given event name
// Callback is called with context as the first argument and the `this`
// The context is the current parsley instance, or window.Parsley if global
// A return value of `false` will interrupt the calls
on:function e(t,i){var r;return this._listeners=this._listeners||{},(this._listeners[t]=this._listeners[t]||[]).push(i),this},
// Deprecated. Use `on` instead
subscribe:function e(t,i){p.listenTo(this,t.toLowerCase(),i)},
// Unregister a callback (or all if none is given) for the given event name
off:function e(t,i){var r=this._listeners&&this._listeners[t];if(r)if(i)for(var n=r.length;n--;)r[n]===i&&r.splice(n,1);else delete this._listeners[t];return this},
// Deprecated. Use `off`
unsubscribe:function e(t,i){p.unsubscribeTo(this,t.toLowerCase())},
// Trigger an event of the given name
// A return value of `false` interrupts the callback chain
// Returns false if execution was interrupted
trigger:function e(t,i,r){i=i||this;var n=this._listeners&&this._listeners[t],s,a;if(n)for(var o=n.length;o--;)if(!1===(s=n[o].call(i,i,r)))return s;return!this.parent||this.parent.trigger(t,i,r)},asyncIsValid:function e(t,i){return h.warnOnce("asyncIsValid is deprecated; please use whenValid instead"),this.whenValid({group:t,force:i})},_findRelated:function e(){return this.options.multiple?p(this.parent.element.querySelectorAll("["+this.options.namespace+'multiple="'+this.options.multiple+'"]')):this.$element}};var l=function e(t,i){var r=t.match(/^\s*\[(.*)\]\s*$/);if(!r)throw'Requirement is not an array: "'+t+'"';var n=r[1].split(",").map(h.trimString);if(n.length!==i)throw"Requirement has "+n.length+" values when "+i+" are needed";return n},u=function e(t,i,r){var n=null,s={};for(var a in t)if(a){var o=r(a);"string"==typeof o&&(o=h.parseRequirement(t[a],o)),s[a]=o}else n=h.parseRequirement(t[a],i);return[n,s]},d=function e(t){p.extend(!0,this,t)};d.prototype={
// Returns `true` iff the given `value` is valid according the given requirements.
validate:function e(t,i){if(this.fn)// Skip first arg (value) and last (instance), combining the rest
// Legacy style validator
return 3<arguments.length&&(// If more args then value, requirement, instance...
i=[].slice.call(arguments,1,-1)),this.fn(t,i);if(Array.isArray(t)){if(!this.validateMultiple)throw"Validator `"+this.name+"` does not handle multiple values";return this.validateMultiple.apply(this,arguments)}var r=arguments[arguments.length-1];if(this.validateDate&&r._isDateInput())return null!==(t=h.parse.date(t))&&this.validateDate.apply(this,arguments);if(this.validateNumber)return!isNaN(t)&&(t=parseFloat(t),this.validateNumber.apply(this,arguments));if(this.validateString)return this.validateString.apply(this,arguments);throw"Validator `"+this.name+"` only handles multiple values"},
// Parses `requirements` into an array of arguments,
// according to `this.requirementType`
parseRequirements:function e(t,i){if("string"!=typeof t)
// Assume requirement already parsed
// but make sure we return an array
return Array.isArray(t)?t:[t];var r=this.requirementType;if(Array.isArray(r)){for(var n=l(t,r.length),s=0;s<n.length;s++)n[s]=h.parseRequirement(r[s],n[s]);return n}return p.isPlainObject(r)?u(r,t,i):[h.parseRequirement(r,t)]},
// Defaults:
requirementType:"string",priority:2};var c=function e(t,i){this.__class__="ValidatorRegistry",
// Default Parsley locale is en
this.locale="en",this.init(t||{},i||{})},f={email:/^((([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-zA-Z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-zA-Z]|\d|-|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-zA-Z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/,
// Follow https://www.w3.org/TR/html5/infrastructure.html#floating-point-numbers
number:/^-?(\d*\.)?\d+(e[-+]?\d+)?$/i,integer:/^-?\d+$/,digits:/^\d+$/,alphanum:/^\w+$/i,date:{test:function e(t){return null!==h.parse.date(t)}},url:new RegExp("^(?:(?:https?|ftp)://)?(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-zA-Z\\u00a1-\\uffff0-9]-*)*[a-zA-Z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-zA-Z\\u00a1-\\uffff]{2,})))(?::\\d{2,5})?(?:/\\S*)?$")};f.range=f.number;
// See http://stackoverflow.com/a/10454560/8279
var m=function e(t){var i=(""+t).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return i?Math.max(0,
// Number of digits right of decimal point.
(i[1]?i[1].length:0)-(
// Adjust for scientific notation.
i[2]?+i[2]:0)):0},g=function e(t,i){return i.map(h.parse[t])},v=function e(n,s){return function(e){for(var t=arguments.length,i=Array(1<t?t-1:0),r=1;r<t;r++)i[r-1]=arguments[r];// Get rid of `input` argument
return i.pop(),s.apply(void 0,[e].concat(_toConsumableArray(g(n,i))))}},y=function e(t){return{validateDate:v("date",t),validateNumber:v("number",t),requirementType:t.length<=2?"string":["string","string"],// Support operators with a 1 or 2 requirement(s)
priority:30}};
// parseArguments('number', ['1', '2']) => [1, 2]
c.prototype={init:function e(t,i){for(var r in this.catalog=i,
// Copy prototype's validators:
this.validators=_extends({},this.validators),t)this.addValidator(r,t[r].fn,t[r].priority);window.Parsley.trigger("parsley:validator:init")},
// Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n
setLocale:function e(t){if(void 0===this.catalog[t])throw new Error(t+" is not available in the catalog");return this.locale=t,this},
// Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`
addCatalog:function e(t,i,r){return"object"==typeof i&&(this.catalog[t]=i),!0===r?this.setLocale(t):this},
// Add a specific message for a given constraint in a given locale
addMessage:function e(t,i,r){return void 0===this.catalog[t]&&(this.catalog[t]={}),this.catalog[t][i]=r,this},
// Add messages for a given locale
addMessages:function e(t,i){for(var r in i)this.addMessage(t,r,i[r]);return this},
// Add a new validator
//
//    addValidator('custom', {
//        requirementType: ['integer', 'integer'],
//        validateString: function(value, from, to) {},
//        priority: 22,
//        messages: {
//          en: "Hey, that's no good",
//          fr: "Aye aye, pas bon du tout",
//        }
//    })
//
// Old API was addValidator(name, function, priority)
//
addValidator:function e(t,i,r){if(this.validators[t])h.warn('Validator "'+t+'" is already defined.');else if(a.hasOwnProperty(t))return void h.warn('"'+t+'" is a restricted keyword and is not a valid validator name.');return this._setValidator.apply(this,arguments)},hasValidator:function e(t){return!!this.validators[t]},updateValidator:function e(t,i,r){return this.validators[t]?this._setValidator.apply(this,arguments):(h.warn('Validator "'+t+'" is not already defined.'),this.addValidator.apply(this,arguments))},removeValidator:function e(t){return this.validators[t]||h.warn('Validator "'+t+'" is not defined.'),delete this.validators[t],this},_setValidator:function e(t,i,r){for(var n in"object"!=typeof i&&(
// Old style validator, with `fn` and `priority`
i={fn:i,priority:r}),i.validate||(i=new d(i)),(this.validators[t]=i).messages||{})this.addMessage(n,t,i.messages[n]);return this},getErrorMessage:function e(t){var i,r;
// Type constraints are a bit different, we have to match their requirements too to find right error message
"type"===t.name?i=(this.catalog[this.locale][t.name]||{})[t.requirements]:i=this.formatMessage(this.catalog[this.locale][t.name],t.requirements);return i||this.catalog[this.locale].defaultMessage||this.catalog.en.defaultMessage},
// Kind of light `sprintf()` implementation
formatMessage:function e(t,i){if("object"!=typeof i)return"string"==typeof t?t.replace(/%s/i,i):"";for(var r in i)t=this.formatMessage(t,i[r]);return t},
// Here is the Parsley default validators list.
// A validator is an object with the following key values:
//  - priority: an integer
//  - requirement: 'string' (default), 'integer', 'number', 'regexp' or an Array of these
//  - validateString, validateMultiple, validateNumber: functions returning `true`, `false` or a promise
// Alternatively, a validator can be a function that returns such an object
//
validators:{notblank:{validateString:function e(t){return/\S/.test(t)},priority:2},required:{validateMultiple:function e(t){return 0<t.length},validateString:function e(t){return/\S/.test(t)},priority:512},type:{validateString:function e(t,i,r){var n=arguments.length<=2||void 0===r?{}:r,s=n.step,a=void 0===s?"any":s,o=n.base,l=void 0===o?0:o,u=f[i];if(!u)throw new Error("validator type `"+i+"` is not supported");if(!u.test(t))return!1;if("number"===i&&!/^any$/i.test(a||"")){var d=Number(t),h=Math.max(m(a),m(l));if(m(d)>h)// Value can't have too many decimals
return!1;
// Be careful of rounding errors by using integers.
var p=function e(t){return Math.round(t*Math.pow(10,h))};if((p(d)-p(l))%p(a)!=0)return!1}return!0},requirementType:{"":"string",step:"string",base:"number"},priority:256},pattern:{validateString:function e(t,i){return i.test(t)},requirementType:"regexp",priority:64},minlength:{validateString:function e(t,i){return t.length>=i},requirementType:"integer",priority:30},maxlength:{validateString:function e(t,i){return t.length<=i},requirementType:"integer",priority:30},length:{validateString:function e(t,i,r){return t.length>=i&&t.length<=r},requirementType:["integer","integer"],priority:30},mincheck:{validateMultiple:function e(t,i){return t.length>=i},requirementType:"integer",priority:30},maxcheck:{validateMultiple:function e(t,i){return t.length<=i},requirementType:"integer",priority:30},check:{validateMultiple:function e(t,i,r){return t.length>=i&&t.length<=r},requirementType:["integer","integer"],priority:30},min:y(function(e,t){return t<=e}),max:y(function(e,t){return e<=t}),range:y(function(e,t,i){return t<=e&&e<=i}),equalto:{validateString:function e(t,i){var r=p(i);return r.length?t===r.val():t===i},priority:256}}};var _={},w=function e(t,i,r){for(var n=[],s=[],a=0;a<t.length;a++){for(var o=!1,l=0;l<i.length;l++)if(t[a].assert.name===i[l].assert.name){o=!0;break}o?s.push(t[a]):n.push(t[a])}return{kept:s,added:n,removed:r?[]:e(i,t,!0).added}};_.Form={_actualizeTriggers:function e(){var t=this;this.$element.on("submit.Parsley",function(e){t.onSubmitValidate(e)}),this.$element.on("click.Parsley",h._SubmitSelector,function(e){t.onSubmitButton(e)}),
// UI could be disabled
!1!==this.options.uiEnabled&&this.element.setAttribute("novalidate","")},focus:function e(){if(!(this._focusedField=null)===this.validationResult||"none"===this.options.focus)return null;for(var t=0;t<this.fields.length;t++){var i=this.fields[t];if(!0!==i.validationResult&&0<i.validationResult.length&&void 0===i.options.noFocus&&(this._focusedField=i.$element,"first"===this.options.focus))break}return null===this._focusedField?null:this._focusedField.focus()},_destroyUI:function e(){
// Reset all event listeners
this.$element.off(".Parsley")}},_.Field={_reflowUI:function e(){
// If this field doesn't have an active UI don't bother doing something
if(this._buildUI(),this._ui){
// Diff between two validation results
var t=w(this.validationResult,this._ui.lastValidationResult);
// Then store current validation result for next reflow
this._ui.lastValidationResult=this.validationResult,
// Handle valid / invalid / none field class
this._manageStatusClass(),
// Add, remove, updated errors messages
this._manageErrorsMessages(t),
// Triggers impl
this._actualizeTriggers(),
// If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user
!t.kept.length&&!t.added.length||this._failedOnce||(this._failedOnce=!0,this._actualizeTriggers())}},
// Returns an array of field's error message(s)
getErrorsMessages:function e(){
// No error message, field is valid
if(!0===this.validationResult)return[];for(var t=[],i=0;i<this.validationResult.length;i++)t.push(this.validationResult[i].errorMessage||this._getErrorMessage(this.validationResult[i].assert));return t},
// It's a goal of Parsley that this method is no longer required [#1073]
addError:function e(t,i){var r=arguments.length<=1||void 0===i?{}:i,n=r.message,s=r.assert,a=r.updateClass,o=void 0===a||a;this._buildUI(),this._addError(t,{message:n,assert:s}),o&&this._errorClass()},
// It's a goal of Parsley that this method is no longer required [#1073]
updateError:function e(t,i){var r=arguments.length<=1||void 0===i?{}:i,n=r.message,s=r.assert,a=r.updateClass,o=void 0===a||a;this._buildUI(),this._updateError(t,{message:n,assert:s}),o&&this._errorClass()},
// It's a goal of Parsley that this method is no longer required [#1073]
removeError:function e(t,i){var r,n=(arguments.length<=1||void 0===i?{}:i).updateClass,s=void 0===n||n;this._buildUI(),this._removeError(t),
// edge case possible here: remove a standard Parsley error that is still failing in this.validationResult
// but highly improbable cuz' manually removing a well Parsley handled error makes no sense.
s&&this._manageStatusClass()},_manageStatusClass:function e(){this.hasConstraints()&&this.needsValidation()&&!0===this.validationResult?this._successClass():0<this.validationResult.length?this._errorClass():this._resetClass()},_manageErrorsMessages:function e(t){if(void 0===this.options.errorsMessagesDisabled){
// Case where we have errorMessage option that configure an unique field error message, regardless failing validators
if(void 0!==this.options.errorMessage)return t.added.length||t.kept.length?(this._insertErrorWrapper(),0===this._ui.$errorsWrapper.find(".parsley-custom-error-message").length&&this._ui.$errorsWrapper.append(p(this.options.errorTemplate).addClass("parsley-custom-error-message")),this._ui.$errorsWrapper.addClass("filled").find(".parsley-custom-error-message").html(this.options.errorMessage)):this._ui.$errorsWrapper.removeClass("filled").find(".parsley-custom-error-message").remove();
// Show, hide, update failing constraints messages
for(var i=0;i<t.removed.length;i++)this._removeError(t.removed[i].assert.name);for(i=0;i<t.added.length;i++)this._addError(t.added[i].assert.name,{message:t.added[i].errorMessage,assert:t.added[i].assert});for(i=0;i<t.kept.length;i++)this._updateError(t.kept[i].assert.name,{message:t.kept[i].errorMessage,assert:t.kept[i].assert})}},_addError:function e(t,i){var r=i.message,n=i.assert;this._insertErrorWrapper(),this._ui.$errorClassHandler.attr("aria-describedby",this._ui.errorsWrapperId),this._ui.$errorsWrapper.addClass("filled").append(p(this.options.errorTemplate).addClass("parsley-"+t).html(r||this._getErrorMessage(n)))},_updateError:function e(t,i){var r=i.message,n=i.assert;this._ui.$errorsWrapper.addClass("filled").find(".parsley-"+t).html(r||this._getErrorMessage(n))},_removeError:function e(t){this._ui.$errorClassHandler.removeAttr("aria-describedby"),this._ui.$errorsWrapper.removeClass("filled").find(".parsley-"+t).remove()},_getErrorMessage:function e(t){var i=t.name+"Message";return void 0!==this.options[i]?window.Parsley.formatMessage(this.options[i],t.requirements):window.Parsley.getErrorMessage(t)},_buildUI:function e(){
// UI could be already built or disabled
if(!this._ui&&!1!==this.options.uiEnabled){var t={};
// Give field its Parsley id in DOM
this.element.setAttribute(this.options.namespace+"id",this.__id__),
/** Generate important UI elements and store them in this **/
// $errorClassHandler is the $element that woul have parsley-error and parsley-success classes
t.$errorClassHandler=this._manageClassHandler(),
// $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer
t.errorsWrapperId="parsley-id-"+(this.options.multiple?"multiple-"+this.options.multiple:this.__id__),t.$errorsWrapper=p(this.options.errorsWrapper).attr("id",t.errorsWrapperId),
// ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly
t.lastValidationResult=[],t.validationInformationVisible=!1,
// Store it in this for later
this._ui=t}},
// Determine which element will have `parsley-error` and `parsley-success` classes
_manageClassHandler:function e(){
// Class handled could also be determined by function given in Parsley options
if("string"==typeof this.options.classHandler&&p(this.options.classHandler).length)return p(this.options.classHandler);
// Class handled could also be determined by function given in Parsley options
var t=this.options.classHandler;
// It might also be the function name of a global function
if("string"==typeof this.options.classHandler&&"function"==typeof window[this.options.classHandler]&&(t=window[this.options.classHandler]),"function"==typeof t){var i=t.call(this,this);
// If this function returned a valid existing DOM element, go for it
if(void 0!==i&&i.length)return i}else{if("object"==typeof t&&t instanceof jQuery&&t.length)return t;t&&h.warn("The class handler `"+t+"` does not exist in DOM nor as a global JS function")}return this._inputHolder()},_inputHolder:function e(){
// if simple element (input, texatrea, select...) it will perfectly host the classes and precede the error container
return this.options.multiple&&"SELECT"!==this.element.nodeName?this.$element.parent():this.$element;
// But if multiple element (radio, checkbox), that would be their parent
},_insertErrorWrapper:function e(){var t=this.options.errorsContainer;
// Nothing to do if already inserted
if(0!==this._ui.$errorsWrapper.parent().length)return this._ui.$errorsWrapper.parent();if("string"==typeof t){if(p(t).length)return p(t).append(this._ui.$errorsWrapper);"function"==typeof window[t]?t=window[t]:h.warn("The errors container `"+t+"` does not exist in DOM nor as a global JS function")}return"function"==typeof t&&(t=t.call(this,this)),"object"==typeof t&&t.length?t.append(this._ui.$errorsWrapper):this._inputHolder().after(this._ui.$errorsWrapper)},_actualizeTriggers:function e(){var t=this,i=this._findRelated(),r;
// Remove Parsley events already bound on this field
i.off(".Parsley"),this._failedOnce?i.on(h.namespaceEvents(this.options.triggerAfterFailure,"Parsley"),function(){t._validateIfNeeded()}):(r=h.namespaceEvents(this.options.trigger,"Parsley"))&&i.on(r,function(e){t._validateIfNeeded(e)})},_validateIfNeeded:function e(t){var i=this;
// For keyup, keypress, keydown, input... events that could be a little bit obstrusive
// do not validate if val length < min threshold on first validation. Once field have been validated once and info
// about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.
t&&/key|input/.test(t.type)&&(!this._ui||!this._ui.validationInformationVisible)&&this.getValue().length<=this.options.validationThreshold||(this.options.debounce?(window.clearTimeout(this._debounced),this._debounced=window.setTimeout(function(){return i.validate()},this.options.debounce)):this.validate())},_resetUI:function e(){
// Reset all event listeners
this._failedOnce=!1,this._actualizeTriggers(),
// Nothing to do if UI never initialized for this field
void 0!==this._ui&&(
// Reset all errors' li
this._ui.$errorsWrapper.removeClass("filled").children().remove(),
// Reset validation class
this._resetClass(),
// Reset validation flags and last validation result
this._ui.lastValidationResult=[],this._ui.validationInformationVisible=!1)},_destroyUI:function e(){this._resetUI(),void 0!==this._ui&&this._ui.$errorsWrapper.remove(),delete this._ui},_successClass:function e(){this._ui.validationInformationVisible=!0,this._ui.$errorClassHandler.removeClass(this.options.errorClass).addClass(this.options.successClass)},_errorClass:function e(){this._ui.validationInformationVisible=!0,this._ui.$errorClassHandler.removeClass(this.options.successClass).addClass(this.options.errorClass)},_resetClass:function e(){this._ui.$errorClassHandler.removeClass(this.options.successClass).removeClass(this.options.errorClass)}};var b=function e(t,i,r){this.__class__="Form",this.element=t,this.$element=p(t),this.domOptions=i,this.options=r,this.parent=window.Parsley,this.fields=[],this.validationResult=null},F={pending:null,resolved:!0,rejected:!1};b.prototype={onSubmitValidate:function e(t){var i=this;
// This is a Parsley generated submit event, do not validate, do not prevent, simply exit and keep normal behavior
if(!0!==t.parsley){
// If we didn't come here through a submit button, use the first one in the form
var r=this._submitSource||this.$element.find(h._SubmitSelector)[0];if(this._submitSource=null,this.$element.find(".parsley-synthetic-submit-button").prop("disabled",!0),!r||null===r.getAttribute("formnovalidate")){window.Parsley._remoteCache={};var n=this.whenValidate({event:t});"resolved"===n.state()&&!1!==this._trigger("submit")||(
// Rejected or pending: cancel this submit
t.stopImmediatePropagation(),t.preventDefault(),"pending"===n.state()&&n.done(function(){i._submit(r)}))}}},onSubmitButton:function e(t){this._submitSource=t.currentTarget},
// internal
// _submit submits the form, this time without going through the validations.
// Care must be taken to "fake" the actual submit button being clicked.
_submit:function e(t){if(!1!==this._trigger("submit")){
// Add submit button's data
if(t){var i=this.$element.find(".parsley-synthetic-submit-button").prop("disabled",!1);0===i.length&&(i=p('<input class="parsley-synthetic-submit-button" type="hidden">').appendTo(this.$element)),i.attr({name:t.getAttribute("name"),value:t.getAttribute("value")})}this.$element.trigger(_extends(p.Event("submit"),{parsley:!0}))}},
// Performs validation on fields while triggering events.
// @returns `true` if all validations succeeds, `false`
// if a failure is immediately detected, or `null`
// if dependant on a promise.
// Consider using `whenValidate` instead.
validate:function e(t){if(1<=arguments.length&&!p.isPlainObject(t)){h.warnOnce("Calling validate on a parsley form without passing arguments as an object is deprecated.");var i=_slice.call(arguments),r,n,s;t={group:i[0],force:i[1],event:i[2]}}return F[this.whenValidate(t).state()]},whenValidate:function e(t){var i,r=this,n=arguments.length<=0||void 0===t?{}:t,s=n.group,a=n.force,o=n.event;(this.submitEvent=o)&&(this.submitEvent=_extends({},o,{preventDefault:function e(){h.warnOnce("Using `this.submitEvent.preventDefault()` is deprecated; instead, call `this.validationResult = false`"),r.validationResult=!1}})),this.validationResult=!0,
// fire validate event to eventually modify things before every validation
this._trigger("validate"),
// Refresh form DOM options and form's fields that could have changed
this._refreshFields();var l=this._withoutReactualizingFormOptions(function(){return p.map(r.fields,function(e){return e.whenValidate({force:a,group:s})})});return(i=h.all(l).done(function(){r._trigger("success")}).fail(function(){r.validationResult=!1,r.focus(),r._trigger("error")}).always(function(){r._trigger("validated")})).pipe.apply(i,_toConsumableArray(this._pipeAccordingToValidationResult()))},
// Iterate over refreshed fields, and stop on first failure.
// Returns `true` if all fields are valid, `false` if a failure is detected
// or `null` if the result depends on an unresolved promise.
// Prefer using `whenValid` instead.
isValid:function e(t){if(1<=arguments.length&&!p.isPlainObject(t)){h.warnOnce("Calling isValid on a parsley form without passing arguments as an object is deprecated.");var i=_slice.call(arguments),r,n;t={group:i[0],force:i[1]}}return F[this.whenValid(t).state()]},
// Iterate over refreshed fields and validate them.
// Returns a promise.
// A validation that immediately fails will interrupt the validations.
whenValid:function e(t){var i=this,r=arguments.length<=0||void 0===t?{}:t,n=r.group,s=r.force;this._refreshFields();var a=this._withoutReactualizingFormOptions(function(){return p.map(i.fields,function(e){return e.whenValid({group:n,force:s})})});return h.all(a)},refresh:function e(){return this._refreshFields(),this},
// Reset UI
reset:function e(){
// Form case: emit a reset event for each field
for(var t=0;t<this.fields.length;t++)this.fields[t].reset();this._trigger("reset")},
// Destroy Parsley instance (+ UI)
destroy:function e(){
// Field case: emit destroy event to clean UI and then destroy stored instance
this._destroyUI();
// Form case: destroy all its fields and then destroy stored instance
for(var t=0;t<this.fields.length;t++)this.fields[t].destroy();this.$element.removeData("Parsley"),this._trigger("destroy")},_refreshFields:function e(){return this.actualizeOptions()._bindFields()},_bindFields:function e(){var n=this,t=this.fields;return this.fields=[],this.fieldsMappedById={},this._withoutReactualizingFormOptions(function(){n.$element.find(n.options.inputs).not(n.options.excluded).each(function(e,t){var i=new window.Parsley.Factory(t,{},n);
// Only add valid and not excluded `Field` and `FieldMultiple` children
if(("Field"===i.__class__||"FieldMultiple"===i.__class__)&&!0!==i.options.excluded){var r=i.__class__+"-"+i.__id__;void 0===n.fieldsMappedById[r]&&(n.fieldsMappedById[r]=i,n.fields.push(i))}}),p.each(h.difference(t,n.fields),function(e,t){t.reset()})}),this},
// Internal only.
// Looping on a form's fields to do validation or similar
// will trigger reactualizing options on all of them, which
// in turn will reactualize the form's options.
// To avoid calling actualizeOptions so many times on the form
// for nothing, _withoutReactualizingFormOptions temporarily disables
// the method actualizeOptions on this form while `fn` is called.
_withoutReactualizingFormOptions:function e(t){var i=this.actualizeOptions;this.actualizeOptions=function(){return this};var r=t();return this.actualizeOptions=i,r},
// Internal only.
// Shortcut to trigger an event
// Returns true iff event is not interrupted and default not prevented.
_trigger:function e(t){return this.trigger("form:"+t)}};var C=function e(t,i,r,n,s){var a=window.Parsley._validatorRegistry.validators[i],o=new d(a);n=n||t.options[i+"Priority"]||o.priority,_extends(this,{validator:o,name:i,requirements:r,priority:n,isDomConstraint:s=!0===s}),this._parseRequirements(t.options)},A=function e(t){var i;return t[0].toUpperCase()+t.slice(1)},E=function e(t,i,r,n){this.__class__="Field",this.element=t,this.$element=p(t),
// Set parent if we have one
void 0!==n&&(this.parent=n),this.options=r,this.domOptions=i,
// Initialize some properties
this.constraints=[],this.constraintsByName={},this.validationResult=!0,
// Bind constraints
this._bindConstraints()},x={pending:null,resolved:!0,rejected:!(C.prototype={validate:function e(t,i){var r;return(r=this.validator).validate.apply(r,[t].concat(_toConsumableArray(this.requirementList),[i]))},_parseRequirements:function e(t){var i=this;this.requirementList=this.validator.parseRequirements(this.requirements,function(e){return t[i.name+A(e)]})}})};E.prototype={
// # Public API
// Validate field and trigger some events for mainly `UI`
// @returns `true`, an array of the validators that failed, or
// `null` if validation is not finished. Prefer using whenValidate
validate:function e(t){1<=arguments.length&&!p.isPlainObject(t)&&(h.warnOnce("Calling validate on a parsley field without passing arguments as an object is deprecated."),t={options:t});var i=this.whenValidate(t);if(!i)// If excluded with `group` option
return!0;switch(i.state()){case"pending":return null;case"resolved":return!0;case"rejected":return this.validationResult}},
// Validate field and trigger some events for mainly `UI`
// @returns a promise that succeeds only when all validations do
// or `undefined` if field is not in the given `group`.
whenValidate:function e(t){var i,r=this,n=arguments.length<=0||void 0===t?{}:t,s=n.force,a=n.group;if(
// do not validate a field if not the same as given validation group
this.refresh(),!a||this._isInGroup(a))return this.value=this.getValue(),
// Field Validate event. `this.value` could be altered for custom needs
this._trigger("validate"),(i=this.whenValid({force:s,value:this.value,_refreshed:!0}).always(function(){r._reflowUI()}).done(function(){r._trigger("success")}).fail(function(){r._trigger("error")}).always(function(){r._trigger("validated")})).pipe.apply(i,_toConsumableArray(this._pipeAccordingToValidationResult()))},hasConstraints:function e(){return 0!==this.constraints.length},
// An empty optional field does not need validation
needsValidation:function e(t){
// If a field is empty and not required, it is valid
// Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators
return void 0===t&&(t=this.getValue()),!(!t.length&&!this._isRequired()&&void 0===this.options.validateIfEmpty)},_isInGroup:function e(t){return Array.isArray(this.options.group)?-1!==p.inArray(t,this.options.group):this.options.group===t},
// Just validate field. Do not trigger any event.
// Returns `true` iff all constraints pass, `false` if there are failures,
// or `null` if the result can not be determined yet (depends on a promise)
// See also `whenValid`.
isValid:function e(t){if(1<=arguments.length&&!p.isPlainObject(t)){h.warnOnce("Calling isValid on a parsley field without passing arguments as an object is deprecated.");var i=_slice.call(arguments),r,n;t={force:i[0],value:i[1]}}var s=this.whenValid(t);return!s||x[s.state()]},
// Just validate field. Do not trigger any event.
// @returns a promise that succeeds only when all validations do
// or `undefined` if the field is not in the given `group`.
// The argument `force` will force validation of empty fields.
// If a `value` is given, it will be validated instead of the value of the input.
whenValid:function e(t){var r=this,i=arguments.length<=0||void 0===t?{}:t,n=i.force,s=void 0!==n&&n,a=i.value,o=i.group,l;
// do not validate a field if not the same as given validation group
if(
// Recompute options and rebind constraints to have latest changes
i._refreshed||this.refresh(),!o||this._isInGroup(o)){
// A field without constraint is valid
if(this.validationResult=!0,!this.hasConstraints())return p.when();
// Value could be passed as argument, needed to add more power to 'field:validate'
if(null==a&&(a=this.getValue()),!this.needsValidation(a)&&!0!==s)return p.when();var u=this._getGroupedConstraints(),d=[];return p.each(u,function(e,t){
// Process one group of constraints at a time, we validate the constraints
// and combine the promises together.
var i=h.all(p.map(t,function(e){return r._validateConstraint(a,e)}));if(d.push(i),"rejected"===i.state())return!1;// Interrupt processing if a group has already failed
}),h.all(d)}},
// @returns a promise
_validateConstraint:function e(t,i){var r=this,n=i.validate(t,this);
// Make sure we return a promise and that we record failures
// Map false to a failed promise
return!1===n&&(n=p.Deferred().reject()),h.all([n]).fail(function(e){r.validationResult instanceof Array||(r.validationResult=[]),r.validationResult.push({assert:i,errorMessage:"string"==typeof e&&e})})},
// @returns Parsley field computed value that could be overrided or configured in DOM
getValue:function e(){var t;
// Value could be overriden in DOM or with explicit options
// Handle wrong DOM or configurations
return null==(t="function"==typeof this.options.value?this.options.value(this):void 0!==this.options.value?this.options.value:this.$element.val())?"":this._handleWhitespace(t)},
// Reset UI
reset:function e(){return this._resetUI(),this._trigger("reset")},
// Destroy Parsley instance (+ UI)
destroy:function e(){
// Field case: emit destroy event to clean UI and then destroy stored instance
this._destroyUI(),this.$element.removeData("Parsley"),this.$element.removeData("FieldMultiple"),this._trigger("destroy")},
// Actualize options and rebind constraints
refresh:function e(){return this._refreshConstraints(),this},_refreshConstraints:function e(){return this.actualizeOptions()._bindConstraints()},refreshConstraints:function e(){return h.warnOnce("Parsley's refreshConstraints is deprecated. Please use refresh"),this.refresh()},
/**
    * Add a new constraint to a field
    *
    * @param {String}   name
    * @param {Mixed}    requirements      optional
    * @param {Number}   priority          optional
    * @param {Boolean}  isDomConstraint   optional
    */
addConstraint:function e(t,i,r,n){if(window.Parsley._validatorRegistry.validators[t]){var s=new C(this,t,i,r,n);
// if constraint already exist, delete it and push new version
"undefined"!==this.constraintsByName[s.name]&&this.removeConstraint(s.name),this.constraints.push(s),this.constraintsByName[s.name]=s}return this},
// Remove a constraint
removeConstraint:function e(t){for(var i=0;i<this.constraints.length;i++)if(t===this.constraints[i].name){this.constraints.splice(i,1);break}return delete this.constraintsByName[t],this},
// Update a constraint (Remove + re-add)
updateConstraint:function e(t,i,r){return this.removeConstraint(t).addConstraint(t,i,r)},
// # Internals
// Internal only.
// Bind constraints from config + options + DOM
_bindConstraints:function e(){
// clean all existing DOM constraints to only keep javascript user constraints
for(var t=[],i={},r=0;r<this.constraints.length;r++)!1===this.constraints[r].isDomConstraint&&(t.push(this.constraints[r]),i[this.constraints[r].name]=this.constraints[r]);
// then re-add Parsley DOM-API constraints
for(var n in this.constraints=t,this.constraintsByName=i,this.options)this.addConstraint(n,this.options[n],void 0,!0);
// finally, bind special HTML5 constraints
return this._bindHtml5Constraints()},
// Internal only.
// Bind specific HTML5 constraints to be HTML5 compliant
_bindHtml5Constraints:function e(){
// html5 required
null!==this.element.getAttribute("required")&&this.addConstraint("required",!0,void 0,!0),
// html5 pattern
null!==this.element.getAttribute("pattern")&&this.addConstraint("pattern",this.element.getAttribute("pattern"),void 0,!0);
// range
var t=this.element.getAttribute("min"),i=this.element.getAttribute("max");null!==t&&null!==i?this.addConstraint("range",[t,i],void 0,!0):null!==t?this.addConstraint("min",t,void 0,!0):null!==i&&this.addConstraint("max",i,void 0,!0),
// length
null!==this.element.getAttribute("minlength")&&null!==this.element.getAttribute("maxlength")?this.addConstraint("length",[this.element.getAttribute("minlength"),this.element.getAttribute("maxlength")],void 0,!0):null!==this.element.getAttribute("minlength")?this.addConstraint("minlength",this.element.getAttribute("minlength"),void 0,!0):null!==this.element.getAttribute("maxlength")&&this.addConstraint("maxlength",this.element.getAttribute("maxlength"),void 0,!0);
// html5 types
var r=h.getType(this.element);
// Small special case here for HTML5 number: integer validator if step attribute is undefined or an integer value, number otherwise
return"number"===r?this.addConstraint("type",["number",{step:this.element.getAttribute("step")||"1",base:t||this.element.getAttribute("value")}],void 0,!0):/^(email|url|range|date)$/i.test(r)?this.addConstraint("type",r,void 0,!0):this},
// Internal only.
// Field is required if have required constraint without `false` value
_isRequired:function e(){return void 0!==this.constraintsByName.required&&!1!==this.constraintsByName.required.requirements},
// Internal only.
// Shortcut to trigger an event
_trigger:function e(t){return this.trigger("field:"+t)},
// Internal only
// Handles whitespace in a value
// Use `data-parsley-whitespace="squish"` to auto squish input value
// Use `data-parsley-whitespace="trim"` to auto trim input value
_handleWhitespace:function e(t){return!0===this.options.trimValue&&h.warnOnce('data-parsley-trim-value="true" is deprecated, please use data-parsley-whitespace="trim"'),"squish"===this.options.whitespace&&(t=t.replace(/\s{2,}/g," ")),"trim"!==this.options.whitespace&&"squish"!==this.options.whitespace&&!0!==this.options.trimValue||(t=h.trimString(t)),t},_isDateInput:function e(){var t=this.constraintsByName.type;return t&&"date"===t.requirements},
// Internal only.
// Returns the constraints, grouped by descending priority.
// The result is thus an array of arrays of constraints.
_getGroupedConstraints:function e(){if(!1===this.options.priorityEnabled)return[this.constraints];
// Create array unique of priorities
for(var t=[],i={},r=0;r<this.constraints.length;r++){var n=this.constraints[r].priority;i[n]||t.push(i[n]=[]),i[n].push(this.constraints[r])}
// Sort them by priority DESC
return t.sort(function(e,t){return t[0].priority-e[0].priority}),t}};var $=E,P=function e(){this.__class__="FieldMultiple"};P.prototype={
// Add new `$element` sibling for multiple field
addElement:function e(t){return this.$elements.push(t),this},
// See `Field._refreshConstraints()`
_refreshConstraints:function e(){var t;
// Select multiple special treatment
if(this.constraints=[],"SELECT"===this.element.nodeName)return this.actualizeOptions()._bindConstraints(),this;
// Gather all constraints for each input in the multiple group
for(var i=0;i<this.$elements.length;i++)
// Check if element have not been dynamically removed since last binding
if(p("html").has(this.$elements[i]).length){t=this.$elements[i].data("FieldMultiple")._refreshConstraints().constraints;for(var r=0;r<t.length;r++)this.addConstraint(t[r].name,t[r].requirements,t[r].priority,t[r].isDomConstraint)}else this.$elements.splice(i,1);return this},
// See `Field.getValue()`
getValue:function e(){
// Value could be overriden in DOM
if("function"==typeof this.options.value)return this.options.value(this);
// Radio input case
if(void 0!==this.options.value)return this.options.value;if("INPUT"===this.element.nodeName){var t=h.getType(this.element);if("radio"===t)return this._findRelated().filter(":checked").val()||"";
// checkbox input case
if("checkbox"===t){var i=[];return this._findRelated().filter(":checked").each(function(){i.push(p(this).val())}),i}}
// Select multiple case
return"SELECT"===this.element.nodeName&&null===this.$element.val()?[]:this.$element.val();
// Default case that should never happen
},_init:function e(){return this.$elements=[this.$element],this}};var V=function e(t,i,r){this.element=t,this.$element=p(t);
// If the element has already been bound, returns its saved Parsley instance
var n=this.$element.data("Parsley");if(n)
// If the saved instance has been bound without a Form parent and there is one given in this call, add it
return void 0!==r&&n.parent===window.Parsley&&(n.parent=r,n._resetOptions(n.options)),"object"==typeof i&&_extends(n.options,i),n;
// Parsley must be instantiated with a DOM element or jQuery $element
if(!this.$element.length)throw new Error("You must bind Parsley on an existing element.");if(void 0!==r&&"Form"!==r.__class__)throw new Error("Parent instance must be a Form instance");return this.parent=r||window.Parsley,this.init(i)};V.prototype={init:function e(t){
// A Form instance is obviously a `<form>` element but also every node that is not an input and has the `data-parsley-validate` attribute
return this.__class__="Parsley",this.__version__="2.8.1",this.__id__=h.generateID(),
// Pre-compute options
this._resetOptions(t),"FORM"===this.element.nodeName||h.checkAttr(this.element,this.options.namespace,"validate")&&!this.$element.is(this.options.inputs)?this.bind("parsleyForm"):this.isMultiple()?this.handleMultiple():this.bind("parsleyField");
// Every other element is bound as a `Field` or `FieldMultiple`
},isMultiple:function e(){var t=h.getType(this.element);return"radio"===t||"checkbox"===t||"SELECT"===this.element.nodeName&&null!==this.element.getAttribute("multiple")},
// Multiples fields are a real nightmare :(
// Maybe some refactoring would be appreciated here...
handleMultiple:function e(){var r=this,t,i,n;
// Special select multiple input
if(
// Handle multiple name
this.options.multiple=this.options.multiple||(t=this.element.getAttribute("name"))||this.element.getAttribute("id"),"SELECT"===this.element.nodeName&&null!==this.element.getAttribute("multiple"))return this.options.multiple=this.options.multiple||this.__id__,this.bind("parsleyFieldMultiple");
// Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it
// Remove special chars
if(!this.options.multiple)return h.warn("To be bound by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.",this.$element),this;this.options.multiple=this.options.multiple.replace(/(:|\.|\[|\]|\{|\}|\$)/g,""),
// Add proper `data-parsley-multiple` to siblings if we have a valid multiple name
t&&p('input[name="'+t+'"]').each(function(e,t){var i=h.getType(t);"radio"!==i&&"checkbox"!==i||t.setAttribute(r.options.namespace+"multiple",r.options.multiple)});for(
// Check here if we don't already have a related multiple instance saved
var s=this._findRelated(),a=0;a<s.length;a++)if(void 0!==(n=p(s.get(a)).data("Parsley"))){this.$element.data("FieldMultiple")||n.addElement(this.$element);break}
// Create a secret Field instance for every multiple field. It will be stored in `data('FieldMultiple')`
// And will be useful later to access classic `Field` stuff while being in a `FieldMultiple` instance
return this.bind("parsleyField",!0),n||this.bind("parsleyFieldMultiple")},
// Return proper `Form`, `Field` or `FieldMultiple`
bind:function e(t,i){var r;switch(t){case"parsleyForm":r=p.extend(new b(this.element,this.domOptions,this.options),new o,window.ParsleyExtend)._bindFields();break;case"parsleyField":r=p.extend(new $(this.element,this.domOptions,this.options,this.parent),new o,window.ParsleyExtend);break;case"parsleyFieldMultiple":r=p.extend(new $(this.element,this.domOptions,this.options,this.parent),new P,new o,window.ParsleyExtend)._init();break;default:throw new Error(t+"is not a supported Parsley type")}return this.options.multiple&&h.setAttr(this.element,this.options.namespace,"multiple",this.options.multiple),void 0!==i?this.$element.data("FieldMultiple",r):(
// Store the freshly bound instance in a DOM element for later access using jQuery `data()`
this.$element.data("Parsley",r),
// Tell the world we have a new Form or Field instance!
r._actualizeTriggers(),r._trigger("init")),r}};var O=p.fn.jquery.split(".");if(parseInt(O[0])<=1&&parseInt(O[1])<8)throw"The loaded version of jQuery is too old. Please upgrade to 1.8.x or better.";O.forEach||h.warn("Parsley requires ES5 to run properly. Please include https://github.com/es-shims/es5-shim");
// Inherit `on`, `off` & `trigger` to Parsley:
var M=_extends(new o,{element:document,$element:p(document),actualizeOptions:null,_resetOptions:null,Factory:V,version:"2.8.1"});
// Supplement Field and Form with Base
// This way, the constructors will have access to those methods
_extends($.prototype,_.Field,o.prototype),_extends(b.prototype,_.Form,o.prototype),
// Inherit actualizeOptions and _resetOptions:
_extends(V.prototype,o.prototype),
// ### jQuery API
// `$('.elem').parsley(options)` or `$('.elem').psly(options)`
p.fn.parsley=p.fn.psly=function(e){if(1<this.length){var t=[];return this.each(function(){t.push(p(this).parsley(e))}),t}
// Return undefined if applied to non existing DOM element
if(0!=this.length)return new V(this[0],e)},
// ### Field and Form extension
// Ensure the extension is now defined if it wasn't previously
void 0===window.ParsleyExtend&&(window.ParsleyExtend={}),
// ### Parsley config
// Inherit from ParsleyDefault, and copy over any existing values
M.options=_extends(h.objectCreate(a),window.ParsleyConfig),window.ParsleyConfig=M.options,// Old way of accessing global options
// ### Globals
window.Parsley=window.psly=M,M.Utils=h,window.ParsleyUtils={},p.each(h,function(e,t){"function"==typeof t&&(window.ParsleyUtils[e]=function(){return h.warnOnce("Accessing `window.ParsleyUtils` is deprecated. Use `window.Parsley.Utils` instead."),h[e].apply(h,arguments)})});
// ### Define methods that forward to the registry, and deprecate all access except through window.Parsley
var D=window.Parsley._validatorRegistry=new c(window.ParsleyConfig.validators,window.ParsleyConfig.i18n);window.ParsleyValidator={},p.each("setLocale addCatalog addMessage addMessages getErrorMessage formatMessage addValidator updateValidator removeValidator hasValidator".split(" "),function(e,t){window.Parsley[t]=function(){return D[t].apply(D,arguments)},window.ParsleyValidator[t]=function(){var e;return h.warnOnce("Accessing the method '"+t+"' through Validator is deprecated. Simply call 'window.Parsley."+t+"(...)'"),(e=window.Parsley)[t].apply(e,arguments)}}),
// ### UI
// Deprecated global object
window.Parsley.UI=_,window.ParsleyUI={removeError:function e(t,i,r){var n=!0!==r;return h.warnOnce("Accessing UI is deprecated. Call 'removeError' on the instance directly. Please comment in issue 1073 as to your need to call this method."),t.removeError(i,{updateClass:n})},getErrorsMessages:function e(t){return h.warnOnce("Accessing UI is deprecated. Call 'getErrorsMessages' on the instance directly."),t.getErrorsMessages()}},p.each("addError updateError".split(" "),function(e,a){window.ParsleyUI[a]=function(e,t,i,r,n){var s=!0!==n;return h.warnOnce("Accessing UI is deprecated. Call '"+a+"' on the instance directly. Please comment in issue 1073 as to your need to call this method."),e[a](t,{message:i,assert:r,updateClass:s})}}),
// ### PARSLEY auto-binding
// Prevent it by setting `ParsleyConfig.autoBind` to `false`
!1!==window.ParsleyConfig.autoBind&&p(function(){
// Works only on `data-parsley-validate`.
p("[data-parsley-validate]").length&&p("[data-parsley-validate]").parsley()});var R=p({}),I=function e(){h.warnOnce("Parsley's pubsub module is deprecated; use the 'on' and 'off' methods on parsley instances or window.Parsley")},T="parsley:";p.listen=function(e,t,i){var r;if(I(),"object"==typeof arguments[1]&&"function"==typeof i&&(r=arguments[1],t=i),"function"!=typeof t)throw new Error("Wrong parameters");window.Parsley.on(s(e),n(t,r))},p.listenTo=function(e,t,i){if(I(),!(e instanceof $||e instanceof b))throw new Error("Must give Parsley instance");if("string"!=typeof t||"function"!=typeof i)throw new Error("Wrong parameters");e.on(s(t),n(i))},p.unsubscribe=function(e,t){if(I(),"string"!=typeof e||"function"!=typeof t)throw new Error("Wrong arguments");window.Parsley.off(s(e),t.parsleyAdaptedCallback)},p.unsubscribeTo=function(e,t){if(I(),!(e instanceof $||e instanceof b))throw new Error("Must give Parsley instance");e.off(s(t))},p.unsubscribeAll=function(t){I(),window.Parsley.off(s(t)),p("form,input,textarea,select").each(function(){var e=p(this).data("Parsley");e&&e.off(s(t))})},
// $.emit is deprecated. Use jQuery events instead.
p.emit=function(e,t){var i;I();var r=t instanceof $||t instanceof b,n=Array.prototype.slice.call(arguments,r?2:1);n.unshift(s(e)),r||(t=window.Parsley),(i=t).trigger.apply(i,_toConsumableArray(n))};var q={},S,k;return p.extend(!0,M,{asyncValidators:{default:{fn:function e(t){
// By default, only status 2xx are deemed successful.
// Note: we use status instead of state() because responses with status 200
// but invalid messages (e.g. an empty body for content type set to JSON) will
// result in state() === 'rejected'.
return 200<=t.status&&t.status<300},url:!1},reverse:{fn:function e(t){
// If reverse option is set, a failing ajax request is considered successful
return t.status<200||300<=t.status},url:!1}},addAsyncValidator:function e(t,i,r,n){return M.asyncValidators[t]={fn:i,url:r||!1,options:n||{}},this}}),M.addValidator("remote",{requirementType:{"":"string",validator:"string",reverse:"boolean",options:"object"},validateString:function e(t,i,r,n){var s={},a,o,l=r.validator||(!0===r.reverse?"reverse":"default");if(void 0===M.asyncValidators[l])throw new Error("Calling an undefined async validator: `"+l+"`");
// Fill current value
-1<(i=M.asyncValidators[l].url||i).indexOf("{value}")?i=i.replace("{value}",encodeURIComponent(t)):s[n.element.getAttribute("name")||n.element.getAttribute("id")]=t;
// Merge options passed in from the function with the ones in the attribute
var u=p.extend(!0,r.options||{},M.asyncValidators[l].options);
// All `$.ajax(options)` could be overridden or extended directly from DOM in `data-parsley-remote-options`
a=p.extend(!0,{},{url:i,data:s,type:"GET"},u),
// Generate store key based on ajax options
n.trigger("field:ajaxoptions",n,a),o=p.param(a),
// Initialise querry cache
void 0===M._remoteCache&&(M._remoteCache={});
// Try to retrieve stored xhr
var d=M._remoteCache[o]=M._remoteCache[o]||p.ajax(a),h=function e(){var t=M.asyncValidators[l].fn.call(n,d,i,r);return t||(// Map falsy results to rejected promise
t=p.Deferred().reject()),p.when(t)};return d.then(h,h)},priority:-1}),M.on("form:submit",function(){M._remoteCache={}}),o.prototype.addAsyncValidator=function(){return h.warnOnce("Accessing the method `addAsyncValidator` through an instance is deprecated. Simply call `Parsley.addAsyncValidator(...)`"),M.addAsyncValidator.apply(M,arguments)},
// This is included with the Parsley library itself,
// thus there is no use in adding it to your project.
M.addMessages("en",{defaultMessage:"This value seems to be invalid.",type:{email:"Favor de ingresar un correo válido.",url:"Favor de ingresar un url válido.",number:"Favor de ingresar un número válido.",integer:"Favor de ingresar un número válido.",digits:"Favor de ingresar un correo válido.",alphanum:"This value should be alphanumeric."},notblank:"Este campo no debe estar vacío.",required:"Este campo es requerido.",pattern:"Este valor no es válido.",min:"Debe ser menor o igual a %s.",max:"Debe ser mayor o igual a %s.",range:"Deve ser entre %s y %s.",minlength:"El dato es muy corto. Debe tener %s dígitos o más.",maxlength:"El dato es muy largo. Debe tener %s dígitos o menos.",length:"Invalido. Debe tener entre %s y %s dígitos de largo.",mincheck:"You must select at least %s choices.",maxcheck:"You must select %s choices or fewer.",check:"You must select between %s and %s choices.",equalto:"This value should be the same."}),M.setLocale("en"),(new e).install(),M});
//# sourceMappingURL=parsley.js.map